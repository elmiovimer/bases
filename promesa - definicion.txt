ğŸ“Œ Â¿QuÃ© es una Promesa en JavaScript?
Una promesa en JavaScript es un objeto que representa un valor que aÃºn no estÃ¡ disponible pero que lo estarÃ¡ en el futuro, ya sea con Ã©xito o con un error.

Es muy Ãºtil para manejar operaciones asÃ­ncronas, como:

Llamadas a APIs.
Lectura/escritura de archivos.
Consultas a bases de datos.
Temporizadores.
ğŸš€ 1. Creando una Promesa
Una promesa se crea con el constructor new Promise(), el cual recibe una funciÃ³n con dos parÃ¡metros:

resolve(): Llama a esta funciÃ³n cuando la operaciÃ³n tiene Ã©xito.
reject(): Llama a esta funciÃ³n cuando ocurre un error.
Ejemplo simple de una promesa que se resuelve en 2 segundos:

javascript
Copy
Edit
const miPromesa = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("âœ… Â¡OperaciÃ³n exitosa!");
    }, 2000);
});

console.log("Esperando...");

miPromesa.then((resultado) => {
    console.log(resultado);
});
ğŸ”¹ Â¿QuÃ© sucede aquÃ­?
Se imprime "Esperando..." en la consola.
Se inicia un setTimeout() de 2 segundos.
Cuando pasan los 2 segundos, se ejecuta resolve().
La promesa se resuelve y ejecuta el cÃ³digo dentro de .then().
Salida en la consola:

scss
Copy
Edit
Esperando...
âœ… Â¡OperaciÃ³n exitosa!  (despuÃ©s de 2 segundos)
ğŸ›‘ 2. Manejo de Errores con .catch()
Si algo falla, podemos usar reject() para manejar errores.

javascript
Copy
Edit
const promesaConError = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject("âŒ OcurriÃ³ un error");
    }, 2000);
});

promesaConError
    .then((resultado) => {
        console.log(resultado);
    })
    .catch((error) => {
        console.error("Error:", error);
    });
ğŸ”¹ Â¿QuÃ© sucede aquÃ­?
La promesa falla despuÃ©s de 2 segundos porque llamamos a reject().
Como no se llamÃ³ resolve(), el .then() no se ejecuta.
Se ejecuta .catch(), que captura el error.
Salida en la consola:

vbnet
Copy
Edit
Error: âŒ OcurriÃ³ un error
â³ 3. Encadenamiento de Promesas (then() en cadena)
Podemos encadenar .then() para manejar mÃºltiples pasos.

javascript
Copy
Edit
const promesaEncadenada = new Promise((resolve) => {
    setTimeout(() => {
        resolve(5);
    }, 1000);
});

promesaEncadenada
    .then((numero) => {
        console.log("NÃºmero inicial:", numero);
        return numero * 2;  // El valor retornado se pasa al siguiente `.then()`
    })
    .then((nuevoNumero) => {
        console.log("Doble del nÃºmero:", nuevoNumero);
        return nuevoNumero * 3;
    })
    .then((resultadoFinal) => {
        console.log("Triple del resultado anterior:", resultadoFinal);
    })
    .catch((error) => {
        console.error("Error:", error);
    });
ğŸ”¹ Â¿QuÃ© sucede aquÃ­?
La promesa se resuelve con el nÃºmero 5 despuÃ©s de 1 segundo.
El primer .then() recibe 5 y devuelve 10 (doble).
El segundo .then() recibe 10 y devuelve 30 (triple).
Se imprime cada valor.
Salida en la consola:

less
Copy
Edit
NÃºmero inicial: 5
Doble del nÃºmero: 10
Triple del resultado anterior: 30
ğŸ”„ 4. Convertir una FunciÃ³n en una Promesa
Si queremos que una funciÃ³n devuelva una promesa, podemos hacerlo asÃ­:

javascript
Copy
Edit
function esperar(ms) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(`EsperÃ© ${ms} ms`), ms);
    });
}

esperar(2000).then((mensaje) => console.log(mensaje));
DespuÃ©s de 2 segundos, se imprime:

yaml
Copy
Edit
EsperÃ© 2000 ms
âš¡ 5. Promesas con async y await
En lugar de usar .then(), podemos usar async y await para escribir cÃ³digo mÃ¡s limpio.

javascript
Copy
Edit
async function obtenerDatos() {
    console.log("Buscando datos...");

    const resultado = await new Promise((resolve) => {
        setTimeout(() => resolve("ğŸ“¡ Datos recibidos"), 2000);
    });

    console.log(resultado);
}

obtenerDatos();
ğŸ”¹ Â¿QuÃ© sucede aquÃ­?
Se imprime "Buscando datos...".
await pausa la ejecuciÃ³n hasta que la promesa se resuelve.
DespuÃ©s de 2 segundos, se imprime "ğŸ“¡ Datos recibidos".
Salida en la consola:

java
Copy
Edit
Buscando datos...
ğŸ“¡ Datos recibidos  (despuÃ©s de 2 segundos)
ğŸš€ ConclusiÃ³n
âœ” Una promesa representa una operaciÃ³n asÃ­ncrona que puede tener Ã©xito o fallar.
âœ” Se maneja con .then() para capturar el resultado y .catch() para manejar errores.
âœ” Se pueden encadenar .then() para realizar varias operaciones secuenciales.
âœ” Con async/await, podemos hacer que el cÃ³digo parezca sÃ­ncrono sin perder el beneficio de la asincronÃ­a.
